# File: create_plots.R
# Description: Create plots from parallel L2 convergence analysis results
# Author: Generated by GitHub Copilot
# Date: 2025-07-03
#
# This script loads results from the parallel L2 convergence analysis and creates publication-ready plots
# Usage: Rscript R/create_plots.R

library(here)
library(ggplot2)
library(gridExtra)
library(cowplot)
library(patchwork)

# Function to load results (parallel or sequential)
load_results <- function(use_parallel = TRUE) {
  if (use_parallel) {
    cat("\nLoading parallel results...\n")
    # Load parallel results
    tryCatch({
      load(here::here("output","data", "L2rates_data", "slowr1_parallel.RData"), envir = .GlobalEnv)
      load(here::here("output","data", "L2rates_data", "fastr1_parallel.RData"), envir = .GlobalEnv)
      load(here::here("output","data", "L2rates_data", "slowr2_parallel.RData"), envir = .GlobalEnv)
      load(here::here("output","data", "L2rates_data", "fastr2_parallel.RData"), envir = .GlobalEnv)
      cat("Successfully loaded all parallel result files.\n")
      return(TRUE)
    }, error = function(e) {
      stop("Error loading parallel result files. Make sure you've run L2ConvergenceAnalysis_Parallel.R first.\n", 
           "Error: ", e$message)
    })
  } else {
    cat("\nLoading sequential results...\n")
    # Load sequential results if not already in memory
    tryCatch({
      if (!exists("slowr1")) load(here::here("output","data", "L2rates_data", "slowr1.RData"), envir = .GlobalEnv)
      if (!exists("fastr1")) load(here::here("output","data", "L2rates_data", "fastr1.RData"), envir = .GlobalEnv)
      if (!exists("slowr2")) load(here::here("output","data", "L2rates_data", "slowr2.RData"), envir = .GlobalEnv)
      if (!exists("fastr2")) load(here::here("output","data", "L2rates_data", "fastr2.RData"), envir = .GlobalEnv)

      # Filter out "simple" and "plug.in" methods if they exist
      if (exists("slowr1")) {
        slowr1 <<- slowr1[slowr1$method != "plug.in", ]
      }
      if (exists("fastr1")) {
        fastr1 <<- fastr1[fastr1$method != "plug.in", ]
      }
      if (exists("slowr2")) {
        slowr2 <<- slowr2[slowr2$method != "plug.in", ]
      }
      if (exists("fastr2")) {
        fastr2 <<- fastr2[fastr2$method != "plug.in", ]
      }
      
      # Rename to match parallel naming convention
      slowr1_parallel <<- slowr1
      fastr1_parallel <<- fastr1
      slowr2_parallel <<- slowr2
      fastr2_parallel <<- fastr2

      cat("Successfully loaded and filtered all sequential result files.\n")
      return(TRUE)
    }, error = function(e) {
      stop("Error loading sequential result files. Make sure you've run L2ConvergenceAnalysis.R first.\n", 
           "Error: ", e$message)
    })
  }
}

# Legacy function for backwards compatibility
load_parallel_results <- function() {
  load_results(use_parallel = TRUE)
}

# Function to create plots from parallel results
create_plots_parallel <- function() {
  cat("\nCreating plots from parallel results...\n")
  
  # Enhanced plotting function (matching the exact style you want)
  create_enhanced_plot <- function(data, title_text) {
    # No need to filter since parallel data doesn't have simple method
    
    ggplot(data, aes(x = log10n, y = log10emise, shape = method)) +
      geom_point(size = 2.5) +
      geom_smooth(method = "lm", se = FALSE, color = "grey50") +  # Grey lines for all methods
      scale_shape_manual(
        values = c("naive" = 16, "resub" = 17, "oracle" = 15),
        name = "Method"
      ) +
      labs(
        title = title_text, 
        x = expression(log[10](n)), 
        y = expression(log[10](L[2]~Norm))
      ) +
      theme_bw(base_size = 13) +
      theme(
        legend.position = "none",  # Remove individual legends, we'll add one shared legend
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank(),      # Remove full border
        axis.line.x = element_line(color = "black"),  # Add bottom axis line
        axis.line.y = element_line(color = "black")   # Add left axis line
      )
  }
  
  # Create individual plots
  cat("Creating individual plots...\n")
  g1 <- create_enhanced_plot(slowr1_parallel, "r = 1, slow K")
  g2 <- create_enhanced_plot(fastr1_parallel, "r = 1, fast K") 
  g3 <- create_enhanced_plot(slowr2_parallel, "r = 2, slow K")
  g4 <- create_enhanced_plot(fastr2_parallel, "r = 2, fast K")

  # Save individual plots
  cat("Saving individual plots...\n")
  ggsave(here::here("output", "plots","L2rates_plots", "L2rate_panel1.png"), g1, width = 8, height = 6, dpi = 300)
  ggsave(here::here("output", "plots","L2rates_plots", "L2rate_panel2.png"), g2, width = 8, height = 6, dpi = 300)
  ggsave(here::here("output", "plots","L2rates_plots", "L2rate_panel3.png"), g3, width = 8, height = 6, dpi = 300)
  ggsave(here::here("output", "plots","L2rates_plots", "L2rate_panel4.png"), g4, width = 8, height = 6, dpi = 300)

  # Create and save grid plot with shared legend (like your image)
  cat("Creating grid plot with shared legend...\n")
  
  # Filter data for legend (same as individual plots)
  legend_data <- slowr1_parallel

  # Create a dummy plot to extract the legend (shape-only)
  legend_plot <- ggplot(legend_data, aes(x = log10n, y = log10emise, shape = method)) +
    geom_point(size = 2.5) +
    scale_shape_manual(
      values = c("naive" = 16, "resub" = 17, "oracle" = 15),
      name = "Method",
      labels = c("naive" = "Naive", "resub" = "Resub", "oracle" = "Oracle")
    ) +
    theme_bw(base_size = 13) +
    theme(legend.position = "bottom",
          legend.title = element_text(face = "bold"),
          legend.text = element_text(size = 12),
          legend.key.size = unit(1, "cm"),
          legend.margin = margin(t = 10))
  
  # Extract legend
  legend <- get_legend(legend_plot)
  
  # Create grid without legends using cowplot
  plots_grid <- plot_grid(g1, g2, g3, g4, ncol = 2, labels = NULL, align = "hv")
  
  # Combine grid with legend
  grid_with_legend <- plot_grid(plots_grid, legend, ncol = 1, rel_heights = c(1, 0.15))

  ggsave(here::here("output", "plots", "L2rates_plots", "L2rates_grid.png"), 
         grid_with_legend, width = 12, height = 10, dpi = 300)
  
  # Create high-quality version for publication
  cat("Creating publication-quality plots...\n")
  
  # Publication-ready theme
  pub_theme <- theme_bw(base_size = 14) +
    theme(
      legend.position = "bottom",
      legend.title = element_text(face = "bold", size = 12),
      plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
      axis.title = element_text(face = "bold", size = 12),
      legend.margin = margin(t = 10),
      panel.grid.minor = element_blank(),
      strip.background = element_rect(fill = "white"),
      strip.text = element_text(face = "bold")
    )
  
  # Publication plot function (with grey lines, clean layout)
  create_pub_plot <- function(data, title_text) {
    # No need to filter since parallel data doesn't have simple method
    
    ggplot(data, aes(x = log10n, y = log10emise, shape = method)) +
      geom_point(size = 3) +
      geom_smooth(method = "lm", se = FALSE, color = "grey50") +  # Grey lines
      scale_shape_manual(
        values = c("naive" = 16, "resub" = 17, "oracle" = 15),
        name = "Method"
      ) +
      labs(
        title = title_text, 
        x = expression(log[10](n)), 
        y = expression(log[10](L[2]~Norm))  # Match the original y-axis label
      ) +
      theme_bw(base_size = 14) +
      theme(
        legend.position = "none",            # Remove individual legends
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank(),      # Remove full border
        axis.line.x = element_line(color = "black"),  # Add bottom axis line
        axis.line.y = element_line(color = "black")   # Add left axis line
      )
  }
  
  # Create publication plots
  pub_g1 <- create_pub_plot(slowr1_parallel, "r = 1, slow K")
  pub_g2 <- create_pub_plot(fastr1_parallel, "r = 1, fast K") 
  pub_g3 <- create_pub_plot(slowr2_parallel, "r = 2, slow K")
  pub_g4 <- create_pub_plot(fastr2_parallel, "r = 2, fast K")

  # Save publication-quality grid
  pub_grid <- grid.arrange(pub_g1, pub_g2, pub_g3, pub_g4, ncol = 2)
  ggsave(here::here("output", "plots", "L2rates_plots", "L2rates_new.png"), 
         pub_grid, width = 16, height = 12, dpi = 600)
  ggsave(here::here("output", "plots", "L2rates_plots", "L2rates_new.pdf"), 
         pub_grid, width = 16, height = 12)
  
  # Print summary statistics (like the original script)
  cat("\nSummary of results:\n")
  scenarios <- list("slowr1" = slowr1_parallel, "fastr1" = fastr1_parallel, 
                   "slowr2" = slowr2_parallel, "fastr2" = fastr2_parallel)

  for (scenario_name in names(scenarios)) {
    cat("\n", scenario_name, ":\n")
    data <- scenarios[[scenario_name]]
    for (method in unique(data$method)) {
      method_data <- data[data$method == method, ]
      if (nrow(method_data) > 1) {
        lm_fit <- lm(log10emise ~ log10n, data = method_data)
        slope <- coef(lm_fit)[2]
        r_squared <- summary(lm_fit)$r.squared
        cat("  ", method, ": slope =", round(slope, 3), ", R² =", round(r_squared, 3), "\n")
      }
    }
  }
  
  # Print LaTeX table (like the original script)
  cat("\nGenerating LaTeX table...\n")
  print_l2_rates_latex_table(slow15_parallel, fast15_parallel, slow25_parallel, fast25_parallel)
  
  cat("\nPlots saved to output/plots/:\n")
  cat("- Individual panels: L2rate_panel1-4_parallel.png\n")
  cat("- Grid layout: L2rates_grid_parallel.png\n") 
  cat("- Publication quality: L2rates_publication_parallel.png/.pdf\n")
}

# Publication plot function (with grey lines, clean layout, shared legend)
create_pub_plots_with_global_legend <- function(
  slowr1_parallel, fastr1_parallel, slowr2_parallel, fastr2_parallel
) {
  library(ggplot2)
  library(patchwork)
  library(here)

  # Inner helper for a single panel
  create_pub_plot <- function(data, deriv_order, scenario_label, show_y_label = TRUE) {
    # Create mathematical expression for the title
    if (deriv_order == 1) {
      title_text <- bquote(f^{(1)} * ": " * .(scenario_label))
    } else {
      title_text <- bquote(f^{(2)} * ": " * .(scenario_label))
    }
    
    # Set y-axis label based on show_y_label parameter
    y_label <- if (show_y_label) expression(log[10](L[2]~Norm)) else ""
    
    ggplot(data, aes(x = log10n, y = log10emise, shape = method)) +
      geom_point(size = 3, color = "grey30") +
      geom_smooth(method = "lm", se = FALSE, color = "grey30", aes(group = method), size = 0.8) +
      scale_shape_manual(
        values = c("naive" = 16, "resub" = 17, "oracle" = 15, "plug.in" = 18),
        name = "Method"
      ) +
      labs(
        title = title_text, 
        x = expression(log[10](n)), 
        y = y_label
      ) +
      theme_bw(base_size = 14) +
      theme(
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line.x = element_line(color = "black"),
        axis.line.y = element_line(color = "black")
      )
  }

  # Create publication plots
  pub_g1 <- create_pub_plot(slow15_parallel, 1, "slow K", show_y_label = TRUE)   # Left column - show y label
  pub_g2 <- create_pub_plot(fast15_parallel, 1, "fast K", show_y_label = FALSE)  # Right column - hide y label
  pub_g3 <- create_pub_plot(slow25_parallel, 2, "slow K", show_y_label = TRUE)   # Left column - show y label
  pub_g4 <- create_pub_plot(fast25_parallel, 2, "fast K", show_y_label = FALSE)  # Right column - hide y label
  
  # Combine using patchwork with global legend
  pub_grid <- (pub_g1 + pub_g2 + pub_g3 + pub_g4) +
    patchwork::plot_layout(ncol = 2, guides = "collect") &
    theme(legend.position = "bottom")

  # Save publication-quality grid
  ggsave(here::here("output", "plots", "L2rates_plots", "L2rates_new.png"), 
         pub_grid, width = 16, height = 12, dpi = 600)
  ggsave(here::here("output", "plots", "L2rates_plots", "L2rates_new.pdf"), 
         pub_grid, width = 16, height = 12)

  # Print summary statistics
  cat("\nSummary of results:\n")
  scenarios <- list("slowr1" = slowr1_parallel, "fastr1" = fastr1_parallel, 
                    "slowr2" = slowr2_parallel, "fastr2" = fastr2_parallel)

  for (scenario_name in names(scenarios)) {
    cat("\n", scenario_name, ":\n")
    data <- scenarios[[scenario_name]]
    for (method in unique(data$method)) {
      method_data <- data[data$method == method, ]
      if (nrow(method_data) > 1) {
        lm_fit <- lm(log10emise ~ log10n, data = method_data)
        slope <- coef(lm_fit)[2]
        r_squared <- summary(lm_fit)$r.squared
        cat("  ", method, ": slope =", round(slope, 3), ", R² =", round(r_squared, 3), "\n")
      }
    }
  }

  # Print LaTeX table
  cat("\nGenerating LaTeX table...\n")
  print_l2_rates_latex_table(slowr1_parallel, fastr1_parallel, slowr2_parallel, fastr2_parallel)

  cat("\nPlots saved to output/plots/:\n")
  cat("- Publication-quality PDF: L2rates_new.pdf\n")
  cat("- Publication-quality PNG: L2rates_new.png\n")
}

# Function to print a LaTeX table of empirical L2 convergence rates (from L2ConvergenceAnalysis.R)
print_l2_rates_latex_table <- function(slowr1, fastr1, slowr2, fastr2) {
  # Helper function to compute slope and confidence interval
  compute_slope_ci <- function(df, method_name) {
    # No need to filter simple since parallel data doesn't have it
    fit <- lm(log10emise ~ log10n, data = df[df$method == method_name, ])
    slope <- coef(fit)[2]
    ci <- confint(fit)[2, ]
    c(slope, ci)
  }
  
  # Methods to report (only those in parallel data)
  methods <- c("naive", "resub", "oracle")
  scenarios <- list(slow15=slow15, fast15=fast15, slow25=slow25, fast25=fast25)
  
  # Compute slopes and CIs for each method and scenario
  rates <- sapply(methods, function(m) {
    unlist(lapply(scenarios, function(scen) {
      tryCatch(compute_slope_ci(scen, m), error = function(e) c(NA, NA, NA))
    }))
  })
  
  # Format for LaTeX
  format_rate <- function(slope, lower, upper) {
    if (is.na(slope)) return("--")
    sprintf("%.2f (%.2f, %.2f)", slope, lower, upper)
  }
  
  # Theoretical optimal rates
  optimal_row <- c("-0.33", "-0.33", "-0.22", "-0.22")
  
  # Build table rows
  rows <- c(
    paste("Optimal", paste(optimal_row, collapse = " & "), "\\\\"),
    sapply(seq_along(methods), function(j) {
      m <- methods[j]
      vals <- rates[,j]
      paste(
        switch(m,
          naive = "Naive",
          resub = "Resub",
          oracle = "Oracle"
        ),
        format_rate(vals[1], vals[2], vals[3]),
        format_rate(vals[4], vals[5], vals[6]),
        format_rate(vals[7], vals[8], vals[9]),
        format_rate(vals[10], vals[11], vals[12]),
        "\\\\"
      )
    })
  )
  
  cat("\\begin{table}[htbp]\n",
      "\\centering\n",
      "\\begin{threeparttable}\n",
      "\\caption{Empirical $L_2$ convergence rates compared with the theoretical optimal.}\n",
      "\\label{tab:optimalRates}\n",
      "\\begin{tabular}{lcccc}\n",
      "\\toprule\n",
      " & \\multicolumn{2}{c}{First Derivative} & \\multicolumn{2}{c}{Second Derivative} \\\\\n",
      "Method & Slow $K$ & Fast $K$ & Slow $K$ & Fast $K$ \\\\\n",
      "\\midrule\n",
      paste(rows, collapse = "\n"),
      "\\bottomrule\n",
      "\\end{tabular}\n",
      "\\begin{tablenotes}\n",
      "\\small\n",
      "\\item Note: Confidence intervals are reported in parentheses. Rates are based on Monte Carlo replications.\n",
      "\\end{tablenotes}\n",
      "\\end{threeparttable}\n",
      "\\end{table}\n"
  )
}


# Main function
main_plots <- function(use_parallel = TRUE) {
  # Ensure output directory exists
  if (!dir.exists(here::here("output", "plots", "L2rates_plots"))) {
    dir.create(here::here("output", "plots", "L2rates_plots"), recursive = TRUE)
  }
  
  # Load results (parallel or sequential)
  load_results(use_parallel = use_parallel)
  
  # Create plots from results using the improved function with global legend
  create_pub_plots_with_global_legend(slow15_parallel, fast15_parallel, slow25_parallel, fast25_parallel)
  
  # Optionally also create the older style plots
  # create_plots_parallel()
  
  cat("\nPlot creation complete!\n")
}

# Run if called directly
if (!interactive()) {
  main_plots(use_parallel = FALSE) # Change to TRUE for parallel results
}
